\chapter{Possible improvements}
    \paragraph{}
    This being a partial and basic solution to the problem, there are many improvements that can be made, for functional aspects like detection,
    and monitoring capabilities as well as for non-functinoal aspects, like performance, usability and overall robustness of the application.

    \section{Performance}
        \paragraph{}
        There are multiple components that could be further optimized, for example, as of current implementation, the process collector is
        a doubly linked list, which is very inefficient for lookups (O(n) complexity). A more efficient implementation would be a resizable hash
        table using quadratic or lilnear probing. Another example of a component that needs optimization is the dictionary used to match paths
        for which we recheck the security token. A better implementation would use a compressed trie and aho corrasick algorithm for matching
        the path.

        \paragraph{}
        Another performance improvement would be to not rematch the path for the same opened file each time we encounter it, but to cache
        the results in a minifilter define structure called "context", which can be attached to any filter manager object (i.e. file object, 
        volume, instance, etc.).

    \section{Detection}
        \paragraph{}
        Currently, only privilege escalation is covered and, partially, file infectors. A very important type of malware that should be covered
        is ransomware. Ransomware is a type of malware that encrypts files and asks for a ransom, usually in the form of cryptocurency, in order
        to decrypt the user's files.

    \section{Revert malicious actions}
        \paragraph{}
        In case of behavioral detection, a process could do some malicious actions before being detected. For example, a ransomware may actually
        encrypt some files or parts of some files before being stopped by the anti-virus solution. In this case, it would be needed to store all
        permanent actions (i.e. file delete) and revert them when and if the process is detected.

    \section{Network Filtering}
        \paragraph{}
        A network filter kernel-mode driver is required in order to monitor and report suspicious network activity inside WSL. For example, such
        a component could possibly detect reverse shell behavior.

    \section{User-Mode Hooking Framework}
        \paragraph{}
        Injecting a shared library into monitored process could be, at least for now, the only way to detect WSL process hollowing or
        process injection.
